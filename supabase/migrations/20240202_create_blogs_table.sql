-- Create blogs table
create table if not exists public.blogs (
    id bigint generated by default as identity primary key,
    title text not null,
    slug text not null unique,
    excerpt text,
    content jsonb not null,
    image text,
    category text,
    author_id uuid references auth.users(id),
    tags text[] default '{}',
    published boolean default false,
    featured boolean default false,
    views_count bigint default 0,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create function to automatically generate slug from title
create or replace function generate_blog_slug()
returns trigger as $$
declare
  base_slug text;
  new_slug text;
  counter integer := 1;
begin
  -- Convert title to lowercase and replace spaces and special characters with hyphens
  base_slug := lower(regexp_replace(NEW.title, '[^a-zA-Z0-9\s]', '', 'g'));
  base_slug := regexp_replace(base_slug, '\s+', '-', 'g');
  
  -- Initial slug attempt
  new_slug := base_slug;
  
  -- Keep trying new slugs until we find one that doesn't exist
  while exists(select 1 from public.blogs where slug = new_slug and id != NEW.id) loop
    counter := counter + 1;
    new_slug := base_slug || '-' || counter;
  end loop;
  
  NEW.slug := new_slug;
  return NEW;
end;
$$ language plpgsql;

-- Create trigger to generate slug before insert or update
create trigger generate_blog_slug_trigger
  before insert or update of title
  on public.blogs
  for each row
  execute function generate_blog_slug();

-- Create function to automatically update updated_at timestamp
create or replace function update_updated_at_column()
returns trigger as $$
begin
    NEW.updated_at = now();
    return NEW;
end;
$$ language plpgsql;

-- Create trigger to update updated_at timestamp
create trigger update_blogs_updated_at
    before update
    on public.blogs
    for each row
    execute function update_updated_at_column();

-- Enable Row Level Security
alter table public.blogs enable row level security;

-- Create policy to allow anyone to read published blogs
create policy "Anyone can read published blogs"
    on public.blogs
    for select
    using (published = true);

-- Create policy to allow authenticated users to read all blogs
create policy "Authenticated users can read all blogs"
    on public.blogs
    for select
    using (auth.role() = 'authenticated');

-- Create policy to allow only admins to insert blogs
create policy "Only admins can create blogs"
    on public.blogs
    for insert
    with check (
        exists (
            select 1 from public.profiles
            where profiles.id = auth.uid()
            and profiles.role = 'admin'
        )
    );

-- Create policy to allow only admins to update blogs
create policy "Only admins can update blogs"
    on public.blogs
    for update
    using (
        exists (
            select 1 from public.profiles
            where profiles.id = auth.uid()
            and profiles.role = 'admin'
        )
    )
    with check (
        exists (
            select 1 from public.profiles
            where profiles.id = auth.uid()
            and profiles.role = 'admin'
        )
    );

-- Create policy to allow only admins to delete blogs
create policy "Only admins can delete blogs"
    on public.blogs
    for delete
    using (
        exists (
            select 1 from public.profiles
            where profiles.id = auth.uid()
            and profiles.role = 'admin'
        )
    );

-- Create index for faster searches
create index if not exists blogs_title_idx on public.blogs using gin (to_tsvector('french', title));
create index if not exists blogs_content_idx on public.blogs using gin (content);
create index if not exists blogs_category_idx on public.blogs (category);
create index if not exists blogs_created_at_idx on public.blogs (created_at desc);
create index if not exists blogs_slug_idx on public.blogs (slug);
